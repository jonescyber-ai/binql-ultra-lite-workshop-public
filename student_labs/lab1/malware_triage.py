"""
Malware Triage Script for Lab 1.6.

This script queries the Neo4j program graph to produce a malware triage report
for a given binary. It focuses on behavioral indicators relevant to malware analysis:
- Suspicious strings (URLs, IPs, shell commands, crypto keywords)
- Behavioral imports (shell execution, network, process control)
- Classification hints (tags, malware family if present)

Usage (Students):
    source venv/bin/activate
    python -m student_labs.lab1.malware_triage --sha256 <binary_sha256>

    # Output as JSON
    python -m student_labs.lab1.malware_triage --sha256 <binary_sha256> --json

Usage (Instructors Only):
    # Run with reference implementation using USE_REFERENCE=1
    source venv/bin/activate
    USE_REFERENCE=1 python -m student_labs.lab1.malware_triage --sha256 <binary_sha256>

NOTE: The USE_REFERENCE=1 environment variable is for INSTRUCTORS ONLY.
      It requires access to the `labs/` folder which contains the reference
      implementations. Students do not have access to this folder, so using
      USE_REFERENCE=1 will result in an ImportError. Students should implement
      the stub functions marked with "### YOUR CODE HERE ###" instead.

Reference: docs/labs/lab1/lab_1_6_malware_triage.md
"""

import argparse
import json
import logging
import os
from pathlib import Path
from typing import Any, Dict, List, Optional

from neo4j import GraphDatabase

from lab_common.binql import get_neo4j_credentials

logger = logging.getLogger(__name__)

# Check if we should use reference implementation
_USE_REFERENCE = os.environ.get("USE_REFERENCE", "").lower() in ("1", "true", "yes")

if _USE_REFERENCE:
    # Import reference implementations to use as fallback
    from labs.lab1 import malware_triage_reference as _ref
    logger.info("Using reference implementation for malware_triage")

# Behavioral imports that indicate potential malicious behavior
BEHAVIORAL_IMPORTS = [
    # Shell/process execution
    "system", "execve", "execl", "execlp", "execle", "execv", "execvp",
    "popen", "fork", "vfork",
    # Network
    "socket", "connect", "bind", "listen", "accept", "send", "recv",
    "sendto", "recvfrom", "gethostbyname",
    # Dynamic loading (for evasion)
    "dlopen", "dlsym", "LoadLibrary", "GetProcAddress",
    # File operations (for persistence/exfiltration)
    "fopen", "open", "creat", "unlink", "rename",
]


def get_binary_info(driver, database: str, sha256: str) -> Optional[Dict[str, Any]]:
    """
    Query basic binary information including classification.

    Args:
        driver: Neo4j driver instance
        database: Database name
        sha256: Binary SHA256 hash

    Returns:
        Dictionary with binary info or None if not found
    """
    if _USE_REFERENCE:
        return _ref.get_binary_info(driver, database, sha256)
    ### YOUR CODE HERE ###
    # TODO: Implement this function
    # Query should return: name, architecture, classification, tags, malware_family, function_count
    pass
    ### END YOUR CODE HERE ###


def get_behavioral_imports(driver, database: str, sha256: str) -> List[str]:
    """
    Query imports that indicate potential malicious behavior.

    Args:
        driver: Neo4j driver instance
        database: Database name
        sha256: Binary SHA256 hash

    Returns:
        List of behavioral import names found in the binary
    """
    if _USE_REFERENCE:
        return _ref.get_behavioral_imports(driver, database, sha256)
    ### YOUR CODE HERE ###
    # TODO: Implement this function
    # Query for imports in BEHAVIORAL_IMPORTS list
    pass
    ### END YOUR CODE HERE ###


def get_suspicious_strings(driver, database: str, sha256: str) -> List[str]:
    """
    Query strings that may indicate malicious behavior.

    Looks for:
    - URLs (http://, https://, ftp://)
    - IP addresses
    - Shell references (/bin/sh, /bin/bash, cmd, powershell)
    - Credential keywords (password, secret, key, token)
    - Download tools (wget, curl, nc, netcat)

    Args:
        driver: Neo4j driver instance
        database: Database name
        sha256: Binary SHA256 hash

    Returns:
        List of suspicious string values (limited to 20)
    """
    if _USE_REFERENCE:
        return _ref.get_suspicious_strings(driver, database, sha256)
    ### YOUR CODE HERE ###
    # TODO: Implement this function
    # Use regex patterns to find suspicious strings
    pass
    ### END YOUR CODE HERE ###


def get_import_count(driver, database: str, sha256: str) -> int:
    """
    Get total count of imports for the binary.

    Args:
        driver: Neo4j driver instance
        database: Database name
        sha256: Binary SHA256 hash

    Returns:
        Total number of imports
    """
    if _USE_REFERENCE:
        return _ref.get_import_count(driver, database, sha256)
    ### YOUR CODE HERE ###
    # TODO: Implement this function
    pass
    ### END YOUR CODE HERE ###


def compute_malware_risk(
    behavioral_imports: List[str],
    suspicious_strings: List[str],
    malware_family: Optional[str] = None,
) -> str:
    """
    Compute malware risk level based on behavioral indicators.

    Scoring:
    - Each behavioral import: +2 points
    - Each suspicious string: +1 point
    - Known malware family: +10 points

    Risk levels:
    - CRITICAL: score >= 15
    - HIGH: score >= 8
    - MEDIUM: score >= 3
    - LOW: score < 3

    Args:
        behavioral_imports: List of behavioral import names
        suspicious_strings: List of suspicious string values
        malware_family: Malware family name if known

    Returns:
        Risk level string: "LOW", "MEDIUM", "HIGH", or "CRITICAL"
    """
    if _USE_REFERENCE:
        return _ref.compute_malware_risk(behavioral_imports, suspicious_strings, malware_family)
    ### YOUR CODE HERE ###
    # TODO: Implement this function
    pass
    ### END YOUR CODE HERE ###


def generate_report(
    sha256: str,
    binary_info: Dict[str, Any],
    behavioral_imports: List[str],
    suspicious_strings: List[str],
    import_count: int,
    risk_level: str,
) -> str:
    """
    Generate a human-readable malware triage report.

    Args:
        sha256: Binary SHA256 hash
        binary_info: Dictionary with binary metadata
        behavioral_imports: List of behavioral import names
        suspicious_strings: List of suspicious string values
        import_count: Total number of imports
        risk_level: Computed risk level

    Returns:
        Formatted report string
    """
    lines = []
    lines.append("=== MALWARE TRIAGE REPORT ===")
    lines.append(f"SHA256: {sha256}")
    lines.append(f"Name: {binary_info.get('name', 'unknown')}")
    lines.append(f"Architecture: {binary_info.get('architecture', 'unknown')}")
    lines.append(f"Classification: {binary_info.get('classification', 'unknown')}")
    
    malware_family = binary_info.get("malware_family")
    if malware_family:
        lines.append(f"Malware Family: {malware_family}")
    
    tags = binary_info.get("tags")
    if tags:
        lines.append(f"Tags: {', '.join(tags) if isinstance(tags, list) else tags}")
    
    lines.append("")
    lines.append("--- Summary ---")
    lines.append(f"Functions:          {binary_info.get('function_count', 0)}")
    lines.append(f"Total Imports:      {import_count}")
    lines.append(f"Behavioral Imports: {len(behavioral_imports)}")
    lines.append(f"Suspicious Strings: {len(suspicious_strings)}")
    
    lines.append("")
    lines.append("--- Behavioral Imports ---")
    if behavioral_imports:
        for imp in behavioral_imports:
            lines.append(f"  • {imp}")
    else:
        lines.append("  (none found)")
    
    lines.append("")
    lines.append("--- Suspicious Strings ---")
    if suspicious_strings:
        for s in suspicious_strings[:10]:  # Limit display
            # Truncate long strings
            display_str = s if len(s) <= 60 else s[:57] + "..."
            lines.append(f"  • {display_str}")
        if len(suspicious_strings) > 10:
            lines.append(f"  ... and {len(suspicious_strings) - 10} more")
    else:
        lines.append("  (none found)")
    
    lines.append("")
    lines.append("--- Risk Assessment ---")
    lines.append(f"Risk Level: {risk_level}")
    
    return "\n".join(lines)


def generate_json_report(
    sha256: str,
    binary_info: Dict[str, Any],
    behavioral_imports: List[str],
    suspicious_strings: List[str],
    import_count: int,
    risk_level: str,
) -> str:
    """
    Generate a JSON malware triage report.

    Args:
        sha256: Binary SHA256 hash
        binary_info: Dictionary with binary metadata
        behavioral_imports: List of behavioral import names
        suspicious_strings: List of suspicious string values
        import_count: Total number of imports
        risk_level: Computed risk level

    Returns:
        JSON string
    """
    report = {
        "sha256": sha256,
        "name": binary_info.get("name"),
        "architecture": binary_info.get("architecture"),
        "classification": binary_info.get("classification"),
        "malware_family": binary_info.get("malware_family"),
        "tags": binary_info.get("tags"),
        "function_count": binary_info.get("function_count", 0),
        "import_count": import_count,
        "behavioral_imports": behavioral_imports,
        "suspicious_strings": suspicious_strings,
        "risk_level": risk_level,
    }
    return json.dumps(report, indent=2)


def run_triage(
    driver,
    database: str,
    sha256: str,
    output_json: bool = False,
) -> str:
    """
    Run the complete malware triage analysis.

    Args:
        driver: Neo4j driver instance
        database: Database name
        sha256: Binary SHA256 hash
        output_json: If True, output JSON format

    Returns:
        Report string (text or JSON)
    """
    # Get binary info
    binary_info = get_binary_info(driver, database, sha256)
    if binary_info is None:
        return f"ERROR: Binary with SHA256 {sha256} not found in database"
    
    # Get behavioral imports
    behavioral_imports = get_behavioral_imports(driver, database, sha256) or []
    
    # Get suspicious strings
    suspicious_strings = get_suspicious_strings(driver, database, sha256) or []
    
    # Get import count
    import_count = get_import_count(driver, database, sha256) or 0
    
    # Compute risk level
    malware_family = binary_info.get("malware_family")
    risk_level = compute_malware_risk(behavioral_imports, suspicious_strings, malware_family)
    if risk_level is None:
        risk_level = "UNKNOWN"
    
    # Generate report
    if output_json:
        return generate_json_report(
            sha256, binary_info, behavioral_imports, suspicious_strings,
            import_count, risk_level
        )
    else:
        return generate_report(
            sha256, binary_info, behavioral_imports, suspicious_strings,
            import_count, risk_level
        )


def parse_args():
    """Parse command line arguments."""
    creds = get_neo4j_credentials()
    
    parser = argparse.ArgumentParser(
        description="Generate a malware triage report for a binary in the Neo4j graph."
    )
    parser.add_argument(
        "--sha256",
        required=True,
        help="SHA256 hash of the binary to analyze",
    )
    parser.add_argument(
        "--database",
        default=creds["database"],
        help=f"Neo4j database name (default: {creds['database']})",
    )
    parser.add_argument(
        "--json",
        action="store_true",
        dest="output_json",
        help="Output report as JSON",
    )
    parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="Enable verbose logging",
    )
    return parser.parse_args()


def main() -> None:
    """Main entry point."""
    args = parse_args()
    
    # Setup logging
    log_level = logging.DEBUG if args.verbose else logging.INFO
    logging.basicConfig(
        level=log_level,
        format="%(asctime)s - %(levelname)s - %(name)s - %(message)s",
    )
    
    # Get credentials and connect
    creds = get_neo4j_credentials()
    driver = GraphDatabase.driver(
        creds["uri"],
        auth=(creds["user"], creds["password"]),
    )
    
    try:
        # Run triage
        report = run_triage(
            driver,
            args.database,
            args.sha256,
            output_json=args.output_json,
        )
        print(report)
    finally:
        driver.close()


if __name__ == "__main__":
    module_name = Path(__file__).stem
    logger = logging.getLogger(module_name)
    main()
