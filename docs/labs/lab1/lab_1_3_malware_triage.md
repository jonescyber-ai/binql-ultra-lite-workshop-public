# ðŸ”¹ Lab 1.3 â€” Malware Triage Script

> âœï¸ **This is an implementation lab.** You will write Python code in `student_labs/lab1/malware_triage.py` to complete this lab.
>
> âš ï¸ **This lab requires writing code and running tests.** Follow the "ðŸŽ¯ What You Need To Do" section, then use the "ðŸ“š Implementation Guide" for detailed guidance on each function.

Labs 1.1â€“1.2 focused on CLI commands and Neo4j Browser queries. This step has you **write code** that programmatically
queries the graph and produces a triage report â€” the same pattern you will use in later labs and agent workflows.

---

### âš ï¸ Why benign binaries for a triage lab?

This lab teaches the **mechanics** of automated binary triage â€” querying the graph for behavioral imports, suspicious strings,
and structural indicators. The code you write here works identically on malicious samples; the only difference is what the
queries *find*.

We use **benign binaries** in this workshop for a practical reason: **corporate endpoint protection** (Windows Defender,
CrowdStrike, etc.) scans all files on disk. Even though BCC files contain only lifted program context â€” not executable code â€”
they preserve strings, import names, and other artifacts from the original binary. If the original binary was malware, those
strings alone can trigger false-positive detections that quarantine lab files, generate security alerts, or block git operations.

**What this means for your results:**
- Your triage script will report **low risk scores** for the lab binaries (they are genuinely benign).
- Behavioral imports like `system`, `execve`, or `socket` may still appear â€” benign programs use these APIs too.
- The `malware_family` field will be `null` for all lab binaries (no family metadata is attached).
- The **code and query patterns are production-ready** â€” swap in real threat data and the same pipeline produces actionable triage reports.

---

## Overview

- **Goal:** Write a Python script that takes a binary SHA256, queries the Neo4j graph, and outputs a malware triage summary.
- **Inputs:** Binary SHA256, Neo4j credentials (from `binql_config.yaml` or environment variables).
- **Outputs:** A text/JSON report containing:
  - Basic binary info (name, architecture, function count)
  - Suspicious strings (URLs, IPs, shell commands, crypto keywords)
  - Behavioral imports (e.g., `system`, `execve`, `socket`, `connect`)
  - Classification hints (tags, malware family if present)
  - Malware risk level

---

## ðŸŽ¯ What You Need To Do

### Step 1: Open the Template File

Open `student_labs/lab1/malware_triage.py` and find the stub markers:

```text
### YOUR CODE HERE ###
...
### END YOUR CODE HERE ###
```

### Step 2: Implement the Required Functions

You need to implement **5 functions** (the template already provides Neo4j connection, report generation, and CLI handling):

1. **`get_binary_info(driver, database, sha256)`** â€” Query basic binary information
2. **`get_behavioral_imports(driver, database, sha256)`** â€” Query malware-indicator imports
3. **`get_suspicious_strings(driver, database, sha256)`** â€” Query suspicious strings
4. **`get_import_count(driver, database, sha256)`** â€” Get total import count
5. **`compute_malware_risk(behavioral_imports, suspicious_strings, malware_family)`** â€” Compute risk level

> ðŸ“– **See the "ðŸ“š Implementation Guide" section below for detailed guidance on implementing each function.**

### Step 3: Test Your Implementation

Run the test suite:

```bash
source venv/bin/activate
python -m student_labs.lab1.test.test_lab_1_3
```

### Step 4: Run the Script

Test your implementation against the Bison binary:

```bash
source venv/bin/activate
python -m student_labs.lab1.malware_triage \
  --sha256 9409117ee68a2d75643bb0e0a15c71ab52d4e90fa066e419b1715e029bcdc3dd
```

---

## ðŸ“š Implementation Guide

This section contains detailed guidance for implementing each function. **You only need to implement the code inside the `### YOUR CODE HERE ###` markers.**

> â„¹ï¸ **Already provided in the template:** Neo4j connection setup, the `BEHAVIORAL_IMPORTS` constant, report generation functions (`generate_report`, `generate_json_report`), and CLI handling. You do not need to implement these.

### Function 1 â€” `get_binary_info`

Query basic binary information including classification, tags, malware family, and function count.

```python
def get_binary_info(driver, database: str, sha256: str) -> dict:
    """Query basic binary information including classification."""
    query = """
    MATCH (b:Binary {sha256: $sha256})
    OPTIONAL MATCH (b)-[:HAS_FUNCTION]->(f:Function)
    OPTIONAL MATCH (b)-[:BELONGS_TO_FAMILY]->(fam:MalwareFamily)
    RETURN b.name AS name,
           b.architecture AS architecture,
           b.classification AS classification,
           b.tags AS tags,
           fam.name AS malware_family,
           count(DISTINCT f) AS function_count
    """
    with driver.session(database=database) as session:
        result = session.run(query, sha256=sha256)
        return result.single().data()
```

### Function 2 â€” `get_behavioral_imports`

Query imports that indicate potential malicious behavior. The `BEHAVIORAL_IMPORTS` constant is already defined at the module level in the template â€” use it in your query.

```python
def get_behavioral_imports(driver, database: str, sha256: str) -> list:
    """Query imports that indicate potential malicious behavior."""
    query = """
    MATCH (b:Binary {sha256: $sha256})-[:HAS_FUNCTION]->(:Function)
          -[:ENTRY_BLOCK|ORPHAN_BLOCK]->(:BasicBlock)-[:CALLS_TO]->(imp:ImportSymbol)
    WHERE imp.name IN $behavioral_imports
    RETURN DISTINCT imp.name AS import_name
    ORDER BY imp.name
    """
    with driver.session(database=database) as session:
        result = session.run(query, sha256=sha256, behavioral_imports=BEHAVIORAL_IMPORTS)
        return [r["import_name"] for r in result]
```

> â„¹ï¸ **Note:** `BEHAVIORAL_IMPORTS` is already defined at the top of the template file. You just need to reference it in your query as shown above.

### Function 3 â€” `get_suspicious_strings`

Query strings that may indicate malicious behavior using regex patterns.

```python
def get_suspicious_strings(driver, database: str, sha256: str) -> list:
    """Query strings that may indicate malicious behavior."""
    query = """
    MATCH (b:Binary {sha256: $sha256})-[:HAS_FUNCTION]->(:Function)
          -[:ENTRY_BLOCK|ORPHAN_BLOCK]->(:BasicBlock)-[:USES_STRING]->(s:StringLiteral)
    WHERE s.value =~ '(?i).*(http://|https://|ftp://).*'
       OR s.value =~ '(?i).*\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}.*'
       OR s.value =~ '(?i).*/bin/(sh|bash|cmd|powershell).*'
       OR s.value =~ '(?i).*(password|passwd|secret|key|token|credential).*'
       OR s.value =~ '(?i).*(wget|curl|nc|netcat).*'
    RETURN DISTINCT s.value AS string_value
    LIMIT 20
    """
    with driver.session(database=database) as session:
        result = session.run(query, sha256=sha256)
        return [r["string_value"] for r in result]
```

### Function 4 â€” `get_import_count`

Query the total number of imports for the binary.

```python
def get_import_count(driver, database: str, sha256: str) -> int:
    """Get total count of imports for the binary."""
    query = """
    MATCH (b:Binary {sha256: $sha256})-[:HAS_FUNCTION]->(:Function)
          -[:ENTRY_BLOCK|ORPHAN_BLOCK]->(:BasicBlock)-[:CALLS_TO]->(imp:ImportSymbol)
    RETURN count(DISTINCT imp) AS import_count
    """
    with driver.session(database=database) as session:
        result = session.run(query, sha256=sha256)
        record = result.single()
        return record["import_count"] if record else 0
```

### Function 5 â€” `compute_malware_risk`

Combine findings into a risk level (LOW/MEDIUM/HIGH/CRITICAL). This is pure Python logic â€” no Neo4j query needed.

```python
def compute_malware_risk(behavioral_imports: list, suspicious_strings: list, 
                         malware_family: str = None) -> str:
    """Compute malware risk level based on behavioral indicators."""
    score = 0
    score += len(behavioral_imports) * 2
    score += len(suspicious_strings)
    if malware_family:
        score += 10  # Known malware family is high risk
    
    if score >= 15:
        return "CRITICAL"
    elif score >= 8:
        return "HIGH"
    elif score >= 3:
        return "MEDIUM"
    else:
        return "LOW"
```

---

## âœ… Success Criteria

You have completed this lab when:
- [ ] All 5 stub functions are implemented
- [ ] `python -m student_labs.lab1.test.test_lab_1_3` passes all tests
- [ ] Running the script produces a malware triage report

**Expected test output:**

```text
===== Test Summary =====
Total Tests: 7
Passed:      7
Failed:      0
```

---

## What the Tests Validate

- âœ… Script can connect to Neo4j using `get_neo4j_credentials()`
- âœ… `get_binary_info()` returns expected fields (name, classification, etc.)
- âœ… `get_behavioral_imports()` returns a list of import names
- âœ… `get_suspicious_strings()` returns a list of string values
- âœ… `get_import_count()` returns an integer
- âœ… `compute_malware_risk()` returns valid risk levels
- âœ… CLI runs without error and produces output

---

## Example Output

```text
=== MALWARE TRIAGE REPORT ===
SHA256: 9409117ee68a2d75643bb0e0a15c71ab52d4e90fa066e419b1715e029bcdc3dd
Name: bison_arm
Architecture: ARM
Classification: unknown

--- Summary ---
Functions:          958
Total Imports:      42
Behavioral Imports: 4
Suspicious Strings: 3

--- Behavioral Imports ---
  â€¢ connect
  â€¢ execve
  â€¢ socket
  â€¢ system

--- Suspicious Strings ---
  â€¢ /bin/sh
  â€¢ http://example.com
  â€¢ 192.168.1.1

--- Risk Assessment ---
Risk Level: MEDIUM
```

---

## Solution

When complete, you will have:
- A working malware triage script that programmatically queries the Neo4j graph.
- The script focuses on **behavioral indicators** relevant to malware analysis.
- You understand how to translate the manual Cypher queries from Lab 1.3 into reusable Python functions.

---

## ðŸ“š Additional Reading

This section contains background information about the concepts used in this lab. You do not need to read this to complete the lab.

### What is Already Provided in the Template

The `student_labs/lab1/malware_triage.py` template already includes:

1. **Neo4j connection setup** â€” The `main()` function handles loading credentials via `get_neo4j_credentials()` and creating the driver.

2. **BEHAVIORAL_IMPORTS constant** â€” A list of import names that indicate potential malicious behavior:
   ```python
   BEHAVIORAL_IMPORTS = [
       # Shell/process execution
       "system", "execve", "execl", "execlp", "execle", "execv", "execvp",
       "popen", "fork", "vfork",
       # Network
       "socket", "connect", "bind", "listen", "accept", "send", "recv",
       "sendto", "recvfrom", "gethostbyname",
       # Dynamic loading (for evasion)
       "dlopen", "dlsym", "LoadLibrary", "GetProcAddress",
       # File operations (for persistence/exfiltration)
       "fopen", "open", "creat", "unlink", "rename",
   ]
   ```

3. **Report generation** â€” `generate_report()` and `generate_json_report()` format the output.

4. **CLI handling** â€” `parse_args()` and `main()` handle command-line arguments.

5. **Orchestration** â€” `run_triage()` calls your functions and assembles the report.

### Why These Behavioral Imports Matter

The `BEHAVIORAL_IMPORTS` list targets functions commonly used by malware:

| Category | Functions | Why Suspicious |
|----------|-----------|----------------|
| Shell execution | `system`, `popen`, `execve` | Execute arbitrary commands |
| Process control | `fork`, `vfork` | Spawn child processes |
| Network | `socket`, `connect`, `bind` | C2 communication, data exfiltration |
| Dynamic loading | `dlopen`, `dlsym` | Load code at runtime (evasion) |
| File operations | `fopen`, `unlink`, `rename` | Persistence, file manipulation |

### Suspicious String Patterns

The regex patterns in `get_suspicious_strings` look for:

| Pattern | Example | Why Suspicious |
|---------|---------|----------------|
| URLs | `http://evil.com` | C2 servers, download URLs |
| IP addresses | `192.168.1.1` | Hardcoded C2 addresses |
| Shell paths | `/bin/sh`, `/bin/bash` | Command execution |
| Credentials | `password`, `secret`, `token` | Credential theft |
| Download tools | `wget`, `curl`, `netcat` | Payload download |

---

